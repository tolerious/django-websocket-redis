# SOME DESCRIPTIVE TITLE.
# Copyright (C) Copyright 2016, Jacob Rief
# This file is distributed under the same license as the
# django-websocket-redis package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: django-websocket-redis 0.4.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-03-22 18:11+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.2.0\n"

#: ../../running.rst:5
msgid "Running WebSocket for Redis"
msgstr ""

#: ../../running.rst:7
msgid ""
"**WebSocket for Redis** is a library which runs side by side with Django."
" It has its own separate main loop, which does nothing else than keeping "
"the WebSocket alive and dispatching requests from **Redis** to the "
"configured WebSockets and vice versa."
msgstr ""

#: ../../running.rst:13
msgid "Django with WebSockets for Redis in development mode"
msgstr ""

#: ../../running.rst:15
msgid ""
"With **WebSockets for Redis**, a Django application has immediate access "
"to code written for WebSockets. Make sure, that Redis is up and accepts "
"connections."
msgstr ""

#: ../../running.rst:23
msgid "Then start the Django development server."
msgstr ""

#: ../../running.rst:29
msgid "As usual, this command shall only be used for development."
msgstr ""

#: ../../running.rst:31
msgid ""
"The ``runserver`` command is a monkey patched version of the original "
"Django main loop and works similar to it. If an incoming request is of "
"type WSGI, everything works as usual. However, if the patched handler "
"detects an incoming request wishing to open a WebSocket, then the Django "
"main loop is hijacked by **ws4redis**. This separate loop then waits "
"until ``select`` notifies that some data is available for further "
"processing, or by the WebSocket itself, or by the Redis message queue. "
"This hijacked main loop finishes when the WebSocket is closed or when an "
"error occurs."
msgstr ""

#: ../../running.rst:38
msgid "In development, one thread is created for each open WebSocket."
msgstr ""

#: ../../running.rst:40
msgid ""
"Opened WebSocket connections exchange so called Ping/Pong messages. They "
"keep the connections open, even if there is no payload to be sent. In "
"development mode, the “WebSocket” main loop does not send these stay "
"alive packages, because normally there is no proxy or firewall between "
"the server and the client which could drop the connection. This could be "
"easily implemented, though."
msgstr ""

#: ../../running.rst:47
msgid "Django with WebSockets for Redis as a stand alone uWSGI server"
msgstr ""

#: ../../running.rst:49
msgid ""
"In this configuration the **uWSGI** server owns the main loop. To "
"distinguish WebSockets from normals requests, modify the Python starter "
"module ``wsgi.py`` to"
msgstr ""

#: ../../running.rst:68
msgid "Run uWSGI as stand alone server with"
msgstr ""

#: ../../running.rst:74
msgid ""
"This will answer, both Django and WebSocket requests on port 80 using "
"HTTP. Here the modified ``application`` dispatches incoming requests "
"depending on the URL on either a Django handler or into the WebSocket's "
"main loop."
msgstr ""

#: ../../running.rst:78
msgid ""
"This configuration works for testing uWSGI and low traffic sites. Since "
"uWSGI then runs in one thread/process, blocking calls such as accessing "
"the database, would also block all other HTTP requests. Adding "
"``--gevent-monkey-patch`` to the command line may help here, but Postgres"
" for instance requires to monkey patch its blocking calls with **gevent**"
" using the psycogreen_ library. Moreover, only one CPU core is then used,"
" and static files must be handled by another webserver."
msgstr ""

#: ../../running.rst:86 ../../running.rst:287
msgid "Serving static files"
msgstr ""

#: ../../running.rst:88
msgid ""
"In this configuration, you are not able to serve static files, because "
"Django does not run in debug mode and uWSGI does not know how to server "
"your deployed static files. Therefore in ``urls.py`` add "
"``staticfiles_urlpatterns`` to your urlpatterns:"
msgstr ""

#: ../../running.rst:102
msgid ""
"Remember to remove ``staticfiles_urlpatterns`` when upgrading to a more "
"scalable configuration as explained in the next section."
msgstr ""

#: ../../running.rst:107
msgid "Django with WebSockets for Redis behind NGiNX using uWSGI"
msgstr ""

#: ../../running.rst:109
msgid ""
"This is the most scalable solution. Here two instances of a uWSGI server "
"are spawned, one to handle normal HTTP requests for Django and one to "
"handle WebSocket requests."
msgstr ""

#: ../../running.rst:112
msgid "|websocket4redis|"
msgstr ""

#: ../../running.rst:114
msgid ""
"Assure that you use NGiNX version 1.3.13 or later, since earlier versions"
" have no support for WebSocket proxying. The web server undertakes the "
"task of dispatching normal requests to one uWSGI instance and WebSocket "
"requests to another one. The responsible configuration section for NGiNX "
"shall look like:"
msgstr ""

#: ../../running.rst:133
msgid "For details refer to NGiNX's configuration on `WebSocket proxying`_."
msgstr ""

#: ../../running.rst:137
msgid ""
"Since both uWSGI handlers create their own main loop, they also require "
"their own application and different UNIX sockets. Create two adopter "
"files, one for the Django loop, say ``wsgi_django.py``"
msgstr ""

#: ../../running.rst:147
msgid "and one for the WebSocket loop, say ``wsgi_websocket.py``"
msgstr ""

#: ../../running.rst:159
msgid "Start those two applications as separate uWSGI instances"
msgstr ""

#: ../../running.rst:166
msgid ""
"The NGiNX web server is now configured as a scalable application server "
"which can handle a thousand WebSockets connections concurrently."
msgstr ""

#: ../../running.rst:169
msgid ""
"If you feel uncomfortable with separating WebSocket from normal requests "
"on NGiNX, consider that you already separate static and media requests on"
" the web server. Hence, WebSockets are just another extra routing path."
msgstr ""

#: ../../running.rst:178
msgid "Django with WebSockets for Redis behind Apache-2.4 using uWSGI"
msgstr ""

#: ../../running.rst:180
msgid ""
"Mike Martinka <mike.martinka@ntrepidcorp.com> reported this "
"configuration, which allows to run **ws4redis** with Apache-2.4 and "
"later."
msgstr ""

#: ../../running.rst:183
msgid "Configuratin for uWSGI:"
msgstr ""

#: ../../running.rst:198
msgid "Configuration section for Apache:"
msgstr ""

#: ../../running.rst:208
msgid ""
"Django with WebSockets for Redis as a stand alone uWSGI server in emperor"
" mode"
msgstr ""

#: ../../running.rst:210
msgid ""
"In this configuration the **uWSGI** server owns both main loops. To "
"distinguish WebSockets from normal requests, use uWSGI's `internal "
"routing`_ capabilities."
msgstr ""

#: ../../running.rst:213
msgid ""
"The internal routing capabilities of uWSGI is dependent on the Perl "
"Compatible Regular Expressions (PCRE) library. Make sure that your uWSGI "
"was built with PCRE support if you plan to run in emperor mode. Please "
"refer to the :ref:`PCRE Support` section below for more information."
msgstr ""

#: ../../running.rst:217
msgid ""
"First create the two applications, ``wsgi_django.py`` and "
"``wsgi_websocket.py`` using the same code as in the above example. These "
"are the two entry points for uWSGI. Then create these three ini-files, "
"one for the emperor, say ``uwsgi.ini``:"
msgstr ""

#: ../../running.rst:231
msgid ""
"Create a separate directory named ``vassals`` and add a configuration "
"file for the Websocket loop, say ``vassals/wsserver.ini``:"
msgstr ""

#: ../../running.rst:253
msgid ""
"To the directory named ``vassals``, add a configuration file for the "
"Django loop, say ``vassals/runserver.ini``:"
msgstr ""

#: ../../running.rst:274
msgid ""
"Adopt the virtualenv, pathes, ports and number of threads/processes to "
"your operating system and hosts capabilities."
msgstr ""

#: ../../running.rst:277
msgid "Then start uWSGI:"
msgstr ""

#: ../../running.rst:283
msgid ""
"This configuration scales as well, as the sample from the previous "
"section. It shall be used if no NGiNX server is available."
msgstr ""

#: ../../running.rst:288
msgid ""
"The alert reader will have noticed, that static files are not handled by "
"this configuration. While in theory it is possible to configure **uWSGI**"
" to `deliver static files`_, please note that **uWSGI** is not intended "
"to completly `replace a webserver`_. Therefore, before adding ``route = "
"^/static static:/path/to/static/root`` to the emperors ini-file, consider"
" to place them onto a Content Delivery Network, such as Amazon S3."
msgstr ""

#: ../../running.rst:302
msgid "PCRE Support"
msgstr ""

#: ../../running.rst:303
msgid ""
"If you encounter the error message ``!!! no internal routing support, "
"rebuild with pcre support !!!`` in the logs/console when running in "
"emperor mode, that means you were lacking the PCRE libraries when you "
"first installed uWSGI. You will need to rebuild the uWSGI binaries. To do"
" that uninstall uWSGI, and then download the ``libpcre3`` and "
"``libpcre3-dev`` libraries using your system's package management tool. "
"Once finished, reinstall uWSGI. Credits to this `post`_."
msgstr ""

